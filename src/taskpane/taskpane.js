/* global Word console */
import { marked } from "marked";
import { exchangeToken } from "../api/exchangeToken";

export async function insertText(text) {
  // Write text to the document.
  try {
    await Word.run(async (context) => {
      let body = context.document.body;
      body.insertParagraph(text, Word.InsertLocation.end);
      await context.sync();
    });
  } catch (error) {
    console.log("Error: " + error);
  }
}


export async function insertHeader(text) {
  try {
    await Word.run(async (context) => {
      let sections = context.document.sections;
      context.load(sections, "items");
      await context.sync();

      let header = sections.items[0].getHeader("Primary");

      let paragraph = header.insertParagraph(text, Word.InsertLocation.end);
      paragraph.alignment = "Left";
      paragraph.font.color = "Red";
      paragraph.font.size = 20;

      let date = new Date();
      let formattedDate = date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric",
      });
      let dateParagraph = header.insertParagraph("Date: " + formattedDate, Word.InsertLocation.end);
      dateParagraph.alignment = "Left";
      dateParagraph.font.color = "Blue";
      dateParagraph.font.size = 16;

      await context.sync();
    });
  } catch (error) {
    console.log("Header Formatting Error: " + error);
  }
}


// convert image into base64
async function convertImageToBase64(imagePath) {
  try {
    const base64Image = await fetch(imagePath)
      .then(response => response.blob())
      .then(blob => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          const base64 = reader.result.split(',')[1];
          resolve(base64);
        };
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      }));
    return base64Image;
  } catch (error) {
    console.error("Error converting image to base64:", error);
    return null;
  }
}

export async function insertFooter(imagePath, text) {
  try {
    const base64Image = await convertImageToBase64(imagePath);

    // insert into footer
    await Word.run(async (context) => {
      const sections = context.document.sections;
      context.load(sections, "items");
      await context.sync();

      const footer = sections.items[0].getFooter("Primary");

      const paragraph = footer.insertParagraph("", Word.InsertLocation.end);
      paragraph.alignment = "Left";

      if (base64Image) {
        const pic = paragraph.insertInlinePictureFromBase64(base64Image, Word.InsertLocation.start);
        pic.width = 50; 
        pic.height = 50; 
      }
      // paragraph.insertText(" " + text, Word.InsertLocation.end);

      await context.sync();
    });

  } catch (error) {
    console.error("Error inserting image and text into footer:", error);
  }
}


export async function insertMarkdown(markdownText) {
  try {
    const html = marked.parse(markdownText);

    await Word.run(async (context) => {
      const selection = context.document.getSelection();
      selection.insertHtml(html, Word.InsertLocation.replace); 
      await context.sync();
    });
    await insertFooter("assets/aeka-advisors-logo.png", "Generated by Aeka AI Writer");
  } catch (error) {
    console.log("Markdown Insert Error: " + error);
    throw error;
  }
}

export async function clearWordDocument() {
  try {
    await Word.run(async (context) => {
      context.document.body.clear();
      // Clear headers and footers for all sections
      const sections = context.document.sections;
      context.load(sections, "items");
      await context.sync();
      for (let i = 0; i < sections.items.length; i++) {
        const header = sections.items[i].getHeader("Primary");
        header.clear();
        const footer = sections.items[i].getFooter("Primary");
        footer.clear();
      }
      await context.sync();
    });
  } catch (error) {
    console.log("Error clearing document: " + error);
    throw error;
  }
}


// Helper to decode JWT and check expiration
function decodeJwt(token) {
  if (!token) return null;
  try {
    const payload = JSON.parse(atob(token.split('.')[1]));
    return payload;
  } catch (e) {
    return null;
  }
}

function isJwtExpired(token) {
  const payload = decodeJwt(token);
  if (!payload || !payload.exp) return true;
  const now = Math.floor(Date.now() / 1000);
  return payload.exp < now;
}

// SSO Implementation for Office Add-in
export async function getOfficeAccessToken() {
  // Check for cached JWT in localStorage
  const cachedJwt = localStorage.getItem("auth-token");
  if (cachedJwt && !isJwtExpired(cachedJwt)) {
    return cachedJwt;
  }

  try {
    // Check if Office.js is available
    if (!Office?.auth?.getAccessToken) {
      throw new Error("Office.js SSO is not available. Make sure you're running in a supported Office application.");
    }

    // Get the access token using Office.auth.getAccessToken
    const msAccessToken = await OfficeRuntime.auth.getAccessToken({
      allowSignInPrompt: true,
      allowConsentPrompt: true,
      forMSGraphAccess: true
    });

    if (!msAccessToken) {
      throw new Error("Failed to retrieve access token");
    }

    // Exchange Office token for JWT via Flask API
    const data = await exchangeToken(msAccessToken);
    console.log("JWT received from backend:", data);
    if (!data.token) {
      throw new Error("No JWT returned from backend");
    }
    localStorage.setItem("auth-token", data.token);
    return data.token;
  } catch (error) {
    console.error("SSO/JWT Error:", error);
    throw error;
  }
}

